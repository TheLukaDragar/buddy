import type { PayloadAction } from '@reduxjs/toolkit';
import { createSelector, createSlice } from '@reduxjs/toolkit';
import { ActiveWorkoutState, WorkoutSession } from '../../types/workout';

// Enhanced workout state with Redux pattern
export interface WorkoutState {
  // Core state
  status: 'inactive' | 'selected' | 'preparing' | 'exercising' | 'set-complete' | 'resting' | 'rest-ending' | 'exercise-transition';
  session: WorkoutSession | null;
  
  // Active workout tracking
  activeWorkout: ActiveWorkoutState | null;
  
  // Timers state (we'll handle actual timers in middleware)
  timers: {
    setTimer: {
      active: boolean;
      startTime: number;
      duration: number;
      remaining: number;
    } | null;
    restTimer: {
      active: boolean;
      startTime: number;
      duration: number;
      remaining: number;
      isLastSet: boolean;
    } | null;
  };
  
  // Voice agent integration
  voiceAgent: {
    connected: boolean;
  };
  
  // UI state
  userActivityPingActive: boolean;
  
  // Context messages generated by middleware
  contextMessages: Array<{
    event: string;
    message: string;
    data: any;
    timestamp: number;
    sent: boolean;
  }>;
}

const initialState: WorkoutState = {
  status: 'inactive',
  session: null,
  activeWorkout: null,
  timers: {
    setTimer: null,
    restTimer: null,
  },
  voiceAgent: {
    connected: false,
  },
  userActivityPingActive: false,
  contextMessages: [],
};

// Create the workout slice
const workoutSlice = createSlice({
  name: 'workout',
  initialState,
  reducers: {
    // Workout lifecycle actions
    selectWorkout: {
      reducer: (state, action: PayloadAction<{ session: WorkoutSession; timestamp: number }>) => {
        const { session, timestamp } = action.payload;
        
        state.session = session;
        state.status = 'selected';
        state.activeWorkout = {
          sessionId: session.id,
          currentExerciseIndex: 0,
          currentSetIndex: 0,
          phase: 'preparing',
          startTime: new Date(timestamp),
          currentPhaseStartTime: new Date(timestamp),
          elapsedTime: 0,
          isPaused: false,
          totalPauseTime: 0,
          completedExercises: 0,
          completedSets: 0,
          totalExercises: session.exercises.length,
          totalSets: session.exercises.reduce((total, ex) => total + ex.sets.length, 0),
          currentExercise: session.exercises[0],
          currentSet: session.exercises[0].sets[0],
          exerciseConfirmed: false,
          setsCompleted: [],
          adjustmentsMade: [],
        };

        // Middleware will handle context message generation
      },
      prepare: (session: WorkoutSession) => ({
        payload: { session, timestamp: Date.now() }
      })
    },

    startExercisePreparation: (state) => {
      state.status = 'preparing';
      state.activeWorkout!.phase = 'preparing';
      state.activeWorkout!.currentPhaseStartTime = new Date();
      state.activeWorkout!.exerciseConfirmed = false;
      state.activeWorkout!.timeRemaining = undefined; // Clear rest timer display

      // Middleware will handle context message generation
    },

    confirmReadyAndStartSet: (state) => {

      // Handle different states where user can start a set
      const currentSetIndex = state.activeWorkout!.currentSetIndex;
      const totalSets = state.activeWorkout!.currentExercise?.sets.length || 0;
      const isLastSet = currentSetIndex >= totalSets - 1;

      if (state.status === 'resting') {
        // Clear rest timer
        state.timers.restTimer = null;
        
        if (isLastSet) {
          // User is ready after final set - will complete exercise
          // Middleware will handle context message generation
          return;
        } else {
          // User ready during normal rest - advance to next set and start exercising immediately
          state.activeWorkout!.currentSetIndex++;
          if (state.activeWorkout!.currentExercise) {
            state.activeWorkout!.currentSet = state.activeWorkout!.currentExercise.sets[state.activeWorkout!.currentSetIndex];
          }
          
          // Reset timing data for new set
          state.activeWorkout!.elapsedTime = 0;
          state.activeWorkout!.totalPauseTime = 0;
          state.activeWorkout!.pauseStartTime = undefined;
          state.activeWorkout!.isPaused = false;
          state.activeWorkout!.timeRemaining = undefined; // Clear rest timer display
          
          // Go directly to exercising state (user said they're ready)
          state.status = 'exercising';
          state.activeWorkout!.phase = 'exercising';
          state.activeWorkout!.currentPhaseStartTime = new Date();
          
          // Start set timer
          const targetTime = state.activeWorkout!.currentSet?.targetTime || 45;
          const startTime = Date.now();
          state.timers.setTimer = {
            active: true,
            startTime,
            duration: targetTime * 1000,
            remaining: targetTime * 1000,
          };
        }
      } else if (state.status === 'rest-ending') {
        // Clear rest timer and advance to next set, start exercising immediately
        state.timers.restTimer = null;
        state.activeWorkout!.currentSetIndex++;
        if (state.activeWorkout!.currentExercise) {
          state.activeWorkout!.currentSet = state.activeWorkout!.currentExercise.sets[state.activeWorkout!.currentSetIndex];
        }
        
        // Reset timing data for new set
        state.activeWorkout!.elapsedTime = 0;
        state.activeWorkout!.totalPauseTime = 0;
        state.activeWorkout!.pauseStartTime = undefined;
        state.activeWorkout!.isPaused = false;
        state.activeWorkout!.timeRemaining = undefined; // Clear rest timer display
        
        // Go directly to exercising state (user confirmed readiness during rest-ending)
        state.status = 'exercising';
        state.activeWorkout!.phase = 'exercising';
        state.activeWorkout!.currentPhaseStartTime = new Date();
        
        // Start set timer
        const targetTime = state.activeWorkout!.currentSet?.targetTime || 45;
        const startTime = Date.now();
        state.timers.setTimer = {
          active: true,
          startTime,
          duration: targetTime * 1000,
          remaining: targetTime * 1000,
        };
      } else if (state.status === 'exercise-transition') {
        // User ready for new exercise - transition to preparing
        state.status = 'preparing';
        state.activeWorkout!.phase = 'preparing';
        state.activeWorkout!.currentPhaseStartTime = new Date();
        return;
      }

      // Start the set
      state.status = 'exercising';
      state.activeWorkout!.phase = 'exercising';
      state.activeWorkout!.isPaused = false;
      state.activeWorkout!.totalPauseTime = 0;
      state.activeWorkout!.currentPhaseStartTime = new Date();

      const setDuration = state.activeWorkout!.currentSet?.targetTime || 45;
      const timestamp = Date.now();

      // Set up set timer
      state.timers.setTimer = {
        active: true,
        startTime: timestamp,
        duration: setDuration * 1000,
        remaining: setDuration * 1000,
      };

      state.userActivityPingActive = true;

      // Middleware will handle context message generation
    },

    completeSet: {
      reducer: (state, action: PayloadAction<{ actualReps?: number; timestamp: number }>) => {
        const { actualReps, timestamp } = action.payload;

        // Clear set timer
        state.timers.setTimer = null;
        state.userActivityPingActive = false;

        // Update set data
        state.activeWorkout!.currentSet!.actualReps = actualReps || state.activeWorkout!.currentSet!.targetReps;
        state.activeWorkout!.currentSet!.isCompleted = true;

        // Reset pause state
        state.activeWorkout!.isPaused = false;
        state.activeWorkout!.totalPauseTime = 0;

        state.status = 'set-complete';
        state.activeWorkout!.phase = 'resting';
        state.activeWorkout!.completedSets++;

        // Add to completed sets tracking
        state.activeWorkout!.setsCompleted.push({
          exerciseId: state.activeWorkout!.currentExercise!.id,
          setId: state.activeWorkout!.currentSet!.id,
          performance: {
            actualReps: state.activeWorkout!.currentSet!.actualReps,
            actualWeight: state.activeWorkout!.currentSet!.actualWeight,
            difficulty: state.activeWorkout!.currentSet!.difficulty,
          },
        });

        // Middleware will handle context message generation


      },
      prepare: (actualReps?: number) => ({
        payload: { actualReps, timestamp: Date.now() }
      })
    },

    startRest: (state) => {
      state.status = 'resting';
      const restDuration = state.activeWorkout!.currentSet!.restTimeAfter || 60;
      const timestamp = Date.now();

      // Check if this is the last set of the exercise
      const currentSetIndex = state.activeWorkout!.currentSetIndex;
      const totalSets = state.activeWorkout!.currentExercise!.sets.length || 0;
      const isLastSet = currentSetIndex >= totalSets - 1;

      // Set up rest timer
      state.timers.restTimer = {
        active: true,
        startTime: timestamp,
        duration: restDuration * 1000,
        remaining: restDuration * 1000,
        isLastSet,
      };

      // Middleware will handle context message generation
    },

    triggerRestEnding: (state) => {
      state.status = 'rest-ending';
      
      // Use actual remaining time instead of hardcoded 10
      const actualTimeRemaining = state.activeWorkout?.timeRemaining || 10;
      
      // Middleware will handle context message generation
    },

    completeExercise: (state) => {

      // Clear all timers
      state.timers.setTimer = null;
      state.timers.restTimer = null;
      state.userActivityPingActive = false;

      // Check if workout is complete
      if (state.activeWorkout!.currentExerciseIndex >= state.session!.exercises.length - 1) {
        // Middleware will handle context message generation
        return;
      }

      // Move to next exercise
      state.activeWorkout!.currentExerciseIndex++;
      state.activeWorkout!.currentSetIndex = 0;
      state.activeWorkout!.completedExercises++;
      state.activeWorkout!.currentExercise = state.session!.exercises[state.activeWorkout!.currentExerciseIndex];
      state.activeWorkout!.currentSet = state.activeWorkout!.currentExercise.sets[0];

      // Transition to exercise-transition state
      state.status = 'exercise-transition';

      // Middleware will handle context message generation
    },

    completeWorkout: (state) => {

      // Clear all timers
      state.timers.setTimer = null;
      state.timers.restTimer = null;
      state.userActivityPingActive = false;

      const workoutSummary = {
        sessionName: state.session!.name,
        totalTime: Date.now() - state.activeWorkout!.startTime.getTime(),
        completedExercises: state.activeWorkout!.completedExercises,
        totalExercises: state.activeWorkout!.totalExercises,
        completedSets: state.activeWorkout!.completedSets,
        totalSets: state.activeWorkout!.totalSets,
        setsCompleted: state.activeWorkout!.setsCompleted,
        adjustmentsMade: state.activeWorkout!.adjustmentsMade,
        isFullyCompleted: state.activeWorkout!.completedExercises === state.activeWorkout!.totalExercises,
      };

      // Middleware will handle context message generation

      // Reset to inactive state
      state.status = 'inactive';
      state.session = null;
      state.activeWorkout = null;
    },

    finishWorkoutEarly: (state) => {

      // Clear all timers
      state.timers.setTimer = null;
      state.timers.restTimer = null;
      state.userActivityPingActive = false;

      const workoutSummary = {
        sessionName: state.session!.name,
        totalTime: Date.now() - state.activeWorkout!.startTime.getTime(),
        completedExercises: state.activeWorkout!.completedExercises,
        totalExercises: state.activeWorkout!.totalExercises,
        completedSets: state.activeWorkout!.completedSets,
        totalSets: state.activeWorkout!.totalSets,
        setsCompleted: state.activeWorkout!.setsCompleted,
        adjustmentsMade: state.activeWorkout!.adjustmentsMade,
        isFullyCompleted: false,
        finishedEarly: true,
        currentExercise: state.activeWorkout!.currentExercise?.name,
        currentSet: state.activeWorkout!.currentSetIndex + 1,
      };

      // Middleware will handle context message generation

      // Reset to inactive state
      state.status = 'inactive';
      state.session = null;
      state.activeWorkout = null;
    },

    // Voice agent integration
    setVoiceAgentStatus: (state, action: PayloadAction<boolean>) => {
      state.voiceAgent.connected = action.payload;
    },

    // Timer updates (called by middleware)
    updateSetTimer: (state, action: PayloadAction<{ remaining: number; elapsed: number }>) => {
      if (state.timers.setTimer) {
        state.timers.setTimer.remaining = action.payload.remaining;
      }
      if (state.activeWorkout) {
        state.activeWorkout.elapsedTime = action.payload.elapsed;
        state.activeWorkout.exactSeconds = Math.floor(action.payload.elapsed / 1000);
      }
    },

    updateRestTimer: (state, action: PayloadAction<{ remaining: number; elapsed: number }>) => {
      if (state.timers.restTimer) {
        state.timers.restTimer.remaining = action.payload.remaining;
      }
      if (state.activeWorkout) {
        state.activeWorkout.timeRemaining = Math.floor(action.payload.remaining / 1000);
      }
    },

    // Timer expiration (called by middleware)
    setTimerExpired: (state) => {
      // Just clear the timer - middleware will handle dispatching completeSet
      if (state.status === 'exercising') {
        state.timers.setTimer = null;
        state.userActivityPingActive = false;
      }
    },

    restTimerExpired: (state) => {
      if (state.status === 'resting') {
        // Trigger rest ending (middleware handles isLastSet logic)
        state.status = 'rest-ending';
        
        // Use actual remaining time instead of hardcoded 10
        const actualTimeRemaining = state.activeWorkout?.timeRemaining || 10;
        
        // Middleware will handle context message generation
      } else if (state.status === 'rest-ending') {
        // Rest timer fully expired - auto-advance to preparing state (middleware handles isLastSet)
        state.timers.restTimer = null;
        
        if (state.activeWorkout) {
          // Advance to next set
          state.activeWorkout.currentSetIndex++;
          if (state.activeWorkout.currentExercise) {
            state.activeWorkout.currentSet = state.activeWorkout.currentExercise.sets[state.activeWorkout.currentSetIndex];
          }
          
          // Reset timing data for new set
          state.activeWorkout.elapsedTime = 0;
          state.activeWorkout.totalPauseTime = 0;
          state.activeWorkout.pauseStartTime = undefined;
          state.activeWorkout.isPaused = false;
          state.activeWorkout.timeRemaining = undefined; // Clear rest timer display
          
          // Go to preparing state
          state.status = 'preparing';
          state.activeWorkout.phase = 'preparing';
          state.activeWorkout.currentPhaseStartTime = new Date();
          state.activeWorkout.exerciseConfirmed = false;
          
          // Middleware will handle context message generation
        }
      }
    },

    // Pause/Resume - Pure state setter (no logic)
    pauseSet: (state, action: PayloadAction<{ reason: string }>) => {
      state.activeWorkout!.isPaused = true;
      state.activeWorkout!.pauseStartTime = new Date();
      
      // Pause appropriate timer based on current state
      if (state.status === 'exercising' && state.timers.setTimer) {
        state.timers.setTimer.active = false;
      } else if ((state.status === 'resting' || state.status === 'rest-ending') && state.timers.restTimer) {
        state.timers.restTimer.active = false;
      }
      
      state.userActivityPingActive = false;

      // Middleware will handle context message generation
    },

    resumeSet: (state) => {
      // Calculate pause duration and add to total
      if (state.activeWorkout!.pauseStartTime) {
        const pauseDuration = Date.now() - state.activeWorkout!.pauseStartTime.getTime();
        state.activeWorkout!.totalPauseTime += pauseDuration;
      }

      state.activeWorkout!.isPaused = false;
      state.activeWorkout!.pauseStartTime = undefined;
      
      // Resume appropriate timer based on current state
      if (state.status === 'exercising' && state.timers.setTimer) {
        state.timers.setTimer.active = true;
      } else if ((state.status === 'resting' || state.status === 'rest-ending') && state.timers.restTimer) {
        state.timers.restTimer.active = true;
      }
      
      state.userActivityPingActive = true;

      // Middleware will handle context message generation
    },

    // Adjustments - Pure state setters
    adjustWeight: (state, action: PayloadAction<{ newWeight: number; reason: string }>) => {
      const { newWeight, reason } = action.payload;
      const oldWeight = state.activeWorkout!.currentSet!.targetWeight || 0;
      
      // Update current set and all subsequent sets in current exercise
      const currentExercise = state.activeWorkout!.currentExercise!;
      const currentSetIndex = state.activeWorkout!.currentSetIndex;
      
      for (let i = currentSetIndex; i < currentExercise.sets.length; i++) {
        currentExercise.sets[i].targetWeight = newWeight;
      }
      
      // Update the current active set reference
      state.activeWorkout!.currentSet!.targetWeight = newWeight;
      
      state.activeWorkout!.adjustmentsMade.push({
        type: 'weight',
        from: oldWeight,
        to: newWeight,
        reason,
        timestamp: new Date(),
      });

      // Middleware will handle context message generation
    },

    adjustReps: (state, action: PayloadAction<{ newReps: number; reason: string }>) => {
      const { newReps, reason } = action.payload;
      const oldReps = state.activeWorkout!.currentSet!.targetReps;
      
      // Update current set and all subsequent sets in current exercise
      const currentExercise = state.activeWorkout!.currentExercise!;
      const currentSetIndex = state.activeWorkout!.currentSetIndex;
      
      for (let i = currentSetIndex; i < currentExercise.sets.length; i++) {
        currentExercise.sets[i].targetReps = newReps;
      }
      
      // Update the current active set reference
      state.activeWorkout!.currentSet!.targetReps = newReps;
      
      state.activeWorkout!.adjustmentsMade.push({
        type: 'reps',
        from: oldReps,
        to: newReps,
        reason,
        timestamp: new Date(),
      });

      // Middleware will handle context message generation
    },

    adjustRestTime: (state, action: PayloadAction<{ newRestTime: number; reason: string }>) => {
      const { newRestTime, reason } = action.payload;
      const oldRestTime = state.activeWorkout!.currentSet!.restTimeAfter || 60;
      
      // Update current set and all subsequent sets in current exercise
      const currentExercise = state.activeWorkout!.currentExercise!;
      const currentSetIndex = state.activeWorkout!.currentSetIndex;
      
      for (let i = currentSetIndex; i < currentExercise.sets.length; i++) {
        currentExercise.sets[i].restTimeAfter = newRestTime;
      }
      
      // Update the current active set reference
      state.activeWorkout!.currentSet!.restTimeAfter = newRestTime;
      
      state.activeWorkout!.adjustmentsMade.push({
        type: 'rest',
        from: oldRestTime,
        to: newRestTime,
        reason,
        timestamp: new Date(),
      });

      // If currently resting, adjust the timer
      if (['resting', 'rest-ending'].includes(state.status) && state.timers.restTimer) {
        const elapsed = Date.now() - state.timers.restTimer.startTime;
        const remaining = Math.max(10000, newRestTime * 1000 - elapsed);
        
        state.timers.restTimer.duration = newRestTime * 1000;
        state.timers.restTimer.remaining = remaining;
        
        if (remaining > 10000) {
          state.status = 'resting';
        } else {
          state.status = 'rest-ending';
        }
      }

      // Middleware will handle context message generation
    },

    extendRest: (state, action: PayloadAction<{ additionalSeconds: number }>) => {
      const { additionalSeconds } = action.payload;
      
      if (['resting', 'rest-ending'].includes(state.status)) {
        if (state.timers.restTimer) {
          // Extend existing rest timer
          const currentRemaining = state.timers.restTimer.remaining;
          const extendedTime = currentRemaining + (additionalSeconds * 1000);
          
          state.timers.restTimer.remaining = extendedTime;
          state.timers.restTimer.duration += (additionalSeconds * 1000);
          
          // Update status based on new remaining time
          if (extendedTime > 10000) {
            state.status = 'resting';
          } else {
            state.status = 'rest-ending';
          }
        } else {
          // Create a new rest timer with just the additional time (don't modify set's rest time)
          const baseRestDuration = state.activeWorkout?.currentSet?.restTimeAfter || 60;
          const extendedDuration = additionalSeconds; // Only use the additional time
          const timestamp = Date.now();
          
          state.timers.restTimer = {
            active: true,
            startTime: timestamp,
            duration: extendedDuration * 1000,
            remaining: extendedDuration * 1000,
            isLastSet: false, // middleware will determine this
          };
          
          state.status = 'resting';
        }
      }
      
      // Middleware will handle context message generation and timer restart
    },

    // Clear processed context messages
    clearProcessedContextMessages: (state) => {
      state.contextMessages = [];
    },

    // Navigation actions
    jumpToSet: (state, action: PayloadAction<{ targetSetNumber: number; reason: string }>) => {
      const { targetSetNumber, reason } = action.payload;
      const currentExercise = state.activeWorkout!.currentExercise!;
      const targetSetIndex = targetSetNumber - 1;

      // Clear all timers and timing data
      state.timers.setTimer = null;
      state.timers.restTimer = null;
      state.userActivityPingActive = false;

      // Reset all timing data to ensure clean state
      state.activeWorkout!.elapsedTime = 0;
      state.activeWorkout!.totalPauseTime = 0;
      state.activeWorkout!.pauseStartTime = undefined;

      // Update context to target set
      state.activeWorkout!.currentSetIndex = targetSetIndex;
      state.activeWorkout!.currentSet = currentExercise.sets[targetSetIndex];
      state.activeWorkout!.isPaused = false;

      // Transition to preparing state
      state.status = 'preparing';
      state.activeWorkout!.phase = 'preparing';
      state.activeWorkout!.currentPhaseStartTime = new Date();
      
      // Middleware will handle context message generation
    },

    previousSet: (state) => {
      const currentSetIndex = state.activeWorkout!.currentSetIndex;
      
      // Clear all timers and timing data
      state.timers.setTimer = null;
      state.timers.restTimer = null;
      state.userActivityPingActive = false;
      
      // Reset timing data
      state.activeWorkout!.elapsedTime = 0;
      state.activeWorkout!.totalPauseTime = 0;
      state.activeWorkout!.pauseStartTime = undefined;
      
      // Update set data
      state.activeWorkout!.currentSetIndex = currentSetIndex - 1;
      state.activeWorkout!.currentSet = state.activeWorkout!.currentExercise!.sets[currentSetIndex - 1];
      state.activeWorkout!.isPaused = false;
      state.status = 'preparing';
      state.activeWorkout!.phase = 'preparing';
      state.activeWorkout!.currentPhaseStartTime = new Date();
    },

    nextSet: (state) => {
      const currentSetIndex = state.activeWorkout!.currentSetIndex;
      
      // Clear all timers and timing data
      state.timers.setTimer = null;
      state.timers.restTimer = null;
      state.userActivityPingActive = false;
      
      // Reset timing data
      state.activeWorkout!.elapsedTime = 0;
      state.activeWorkout!.totalPauseTime = 0;
      state.activeWorkout!.pauseStartTime = undefined;
      
      // Update set data
      state.activeWorkout!.currentSetIndex = currentSetIndex + 1;
      state.activeWorkout!.currentSet = state.activeWorkout!.currentExercise!.sets[currentSetIndex + 1];
      state.activeWorkout!.isPaused = false;
      state.status = 'preparing';
      state.activeWorkout!.phase = 'preparing';
      state.activeWorkout!.currentPhaseStartTime = new Date();
    },

    // Cleanup
    cleanup: (state) => {
      state.timers.setTimer = null;
      state.timers.restTimer = null;
      state.userActivityPingActive = false;
      state.status = 'inactive';
      state.session = null;
      state.activeWorkout = null;
      state.contextMessages = [];
    },

    // Context message actions for middleware
    addContextMessage: (state, action: PayloadAction<{
      event: string;
      message: string;
      data: any;
    }>) => {
      const { event, message, data } = action.payload;
      state.contextMessages.push({
        event,
        message,
        data,
        timestamp: Date.now(),
        sent: false,
      });
    },

    markContextMessageSent: (state, action: PayloadAction<{ messageIndex: number }>) => {
      const { messageIndex } = action.payload;
      if (state.contextMessages[messageIndex]) {
        state.contextMessages[messageIndex].sent = true;
      }
    },
  },
});

// Export actions
export const {
  selectWorkout,
  startExercisePreparation,
  confirmReadyAndStartSet,
  completeSet,
  startRest,
  triggerRestEnding,
  completeExercise,
  completeWorkout,
  finishWorkoutEarly,
  setVoiceAgentStatus,
  updateSetTimer,
  updateRestTimer,
  setTimerExpired,
  restTimerExpired,
  pauseSet,
  resumeSet,
  adjustWeight,
  adjustReps,
  adjustRestTime,
  extendRest,
  jumpToSet,
  previousSet,
  nextSet,
  clearProcessedContextMessages,
  addContextMessage,
  markContextMessageSent,
  cleanup,
} = workoutSlice.actions;

// Selectors
export const selectWorkoutStatus = (state: { workout: WorkoutState }) => state.workout.status;
export const selectActiveWorkout = (state: { workout: WorkoutState }) => state.workout.activeWorkout;
export const selectCurrentExercise = (state: { workout: WorkoutState }) => state.workout.activeWorkout?.currentExercise;
export const selectCurrentSet = (state: { workout: WorkoutState }) => state.workout.activeWorkout?.currentSet;
export const selectTimers = (state: { workout: WorkoutState }) => state.workout.timers;
export const selectVoiceAgentStatus = (state: { workout: WorkoutState }) => state.workout.voiceAgent;
export const selectContextMessages = (state: { workout: WorkoutState }) => state.workout.contextMessages;
export const selectUnsentContextMessages = (state: { workout: WorkoutState }) => 
  state.workout.contextMessages.filter(msg => !msg.sent);

// Complex selectors
export const selectWorkoutProgress = createSelector(
  [selectActiveWorkout],
  (activeWorkout) => {
    if (!activeWorkout) return { exerciseProgress: 0, setProgress: 0, overallProgress: 0 };
    
    const exerciseProgress = activeWorkout.currentExerciseIndex / activeWorkout.totalExercises;
    const setProgress = activeWorkout.completedSets / activeWorkout.totalSets;
    const overallProgress = (activeWorkout.completedExercises + (activeWorkout.currentSetIndex / (activeWorkout.currentExercise?.sets.length || 1))) / activeWorkout.totalExercises;
    
    return { exerciseProgress, setProgress, overallProgress };
  }
);

export const selectWorkoutContext = createSelector(
  [selectWorkoutStatus, selectActiveWorkout, selectCurrentExercise, selectCurrentSet, selectTimers],
  (status, activeWorkout, currentExercise, currentSet, timers) => {
    if (!activeWorkout || !currentExercise || !currentSet) return null;
    
    return {
      status,
      sessionId: activeWorkout.sessionId,
      exerciseIndex: activeWorkout.currentExerciseIndex,
      setIndex: activeWorkout.currentSetIndex,
      targetReps: currentSet.targetReps,
      targetWeight: currentSet.targetWeight,
      timeRemaining: timers.restTimer?.remaining ? Math.floor(timers.restTimer.remaining / 1000) : undefined,
      currentExercise,
      currentSet,
      isPaused: activeWorkout.isPaused,
      elapsedTime: activeWorkout.elapsedTime,
    };
  }
);

export default workoutSlice.reducer;
